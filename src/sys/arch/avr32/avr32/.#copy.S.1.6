#include <sys/cdefs.h>
#include <sys/errno.h>

#include <machine/assym.h>

/*
 * kcopy(const void *src, void *dst, size_t len);
 *
 * Copy len bytes from src to dst, aborting if we encounter a fatal 
 * page fault.
 *
 * kcopy() _must_ save and restore the old fault handler since it is
 * called by uiomove(), which may be in the path of servicing a non-fatal
 * page fault.
 */
	.text
	.globl kcopy
	.align 2
kcopy:
	stm	--sp, r7, lr
	mov	r7, sp
	sub	sp, 8

	mov	r8, r12 		# swap arguments to call memcpy
	mov	r12, r11
	mov	r11, r8
	
	# set up fault handler
	lda.w	r8, avr32_curlwp
	ld.w	r8, r8[0] 		# curlwp
	ld.w	r8, r8[L_ADDR]		# curlwp->l_addr

	ld.w	r9, r8[U_PCB_ONFAULT]
	st.w	r7[-8], r9		# save old handler on the stack. (curlwp->l_addr.pcb_onfault)
	
	lda.w	r9, kcopyerr
	ld.w	r9, r9[0]		#kcopyerr: The new handler
	st.w	r8[U_PCB_ONFAULT], r9

	rcall	memcpy

	# restore the old handler
	lda.w	r8, avr32_curlwp	
	ld.w	r8, r8[0] 		# curlwp
	ld.w	r8, r8[L_ADDR]		# curlwp->l_addr
	ld.w	r9, r7[-8]
	st.w	r8[U_PCB_ONFAULT], r9	

	mov	r12, 0
	sub	sp, -8	
	ldm	sp++, r7, pc
	.size	kcopy,.-kcopy

/*
 * int copystr(void *kfaddr, void *kdaddr, size_t maxlen, size_t *lencopied)
 *
 * Copy a NIL-terminated string, at most maxlen characters long.  Return the
 * number of characters copied (including the NIL) in *lencopied.  If the  
 * string is too long, return ENAMETOOLONG; else return 0.
 */

	.text
	.globl copystr
	.align 1
copystr:
	stm	--sp, r7, lr
	
	mov	r7, r10
	cp.w	r10, 0
	breq	2f	/* No characters to copy */
	

1:
	ld.ub	r8, r12[0]
	sub	r12, -1
	sub	r10, 1
	st.b	r11[0], r8
	sub	r11, -1

	cp.w	r8, 0	/* Nil-terminated */
	breq	4f

	cp.w	r10, 0	/* More to copy? */
	brne	1b
	
	/* kfaddr is not NIL- terminated */
	mov	r12, ENAMETOOLONG

	/* 
	 * return the number of copied bytes in the
	 * 4th argument if its non-NULL 
	 */
2:	cp.w	r9, 0		
	breq	3f	
	sub 	r7, r10
	st.w	r9[0],r7
	bral	3f

4:	
	mov	r12, 0
	bral	2b
3:
	ldm	sp++, r7,pc
	.size 	copystr,.- copystr

/*          
 * int copyout(void *kaddr, void *uaddr, size_t len)
 * Copies len bytes of data from the kernel-space address kaddr to the
 * user-space address uaddr.  copyout returns 0 on success or EFAULT
 * if a bad address is encountered.
 */   
	.text
	.globl copyout
	.align 1
copyout:
	stm	--sp, lr

	/* 
	 * Set copyerr as the error handler
	 */
	lda.w	r8, avr32_curlwp
	ld.w	r8, r8[0]	#curlwp
	ld.w	r8, r8[L_ADDR]
	lda.w	r9, copyerr
	ld.w	r9, r9[0]
	st.w	r8[U_PCB_ONFAULT], r9
	
	mov	r9, r12
	mov	r12, r11
	mov	r11, r9
	rcall	memcpy

	/*
	 * reset the error handler
	 */
	lda.w	r8, avr32_curlwp
	ld.w	r8, r8[0]	
	ld.w	r8, r8[L_ADDR]
	mov	r9, 0
	st.w	r8[U_PCB_ONFAULT], r9

	mov	r12, 0	
	ldm	sp++, pc
	.size copyout,.-copyout

	.text
	.globl copyerr
	.align 1
copyerr:
#if 0
	stm	--sp, lr

	lda.w	r12, avr32_curlwp
	ld.w	r12, r12[0]	
	ld.w	r12, r12[L_ADDR]

	mov	r11, 0
	st.w	r12[U_PCB_ONFAULT], r11

	mov	r12, EFAULT
	ldm	sp++, pc
#else
	lddpc	r12,copyerr_panic	
	rcall	panic
	
copyerr_panic: 
	.ascii "copyerr\0"
#endif

/*
 * int copyinstr(void *uaddr, void *kaddr, size_t maxlen, size_t *lencopied)
 * Copy a NIL-terminated string, at most maxlen characters long, from the
 * user's address space.  Return the number of characters copied (including
 * the NIL) in *lencopied.  If the string is too long, return ENAMETOOLONG;
 * else return 0 or EFAULT. 
 */

	.text
	.globl copyinstr
	.align 2
copyinstr:
	
	stm	--sp, r6-r7, lr
	mov	r7, r10

	lda.w	r8, avr32_curlwp
	ld.w	r8, r8[0]
	ld.w	r8, r8[L_ADDR]
	lda.w	r6, copystrerr
	ld.w	r6, r6[0]
	st.w	r8[U_PCB_ONFAULT], r6

	cp.w	r10, 0
	breq	4f

1:	ld.ub	r8, r12[0]
	sub	r10, 1
	st.b	r11[0], r8
	cp.w	r8, 0
	breq	2f
	sub	r12, -1
	sub	r11, -1

	cp.w	r10, 0
	brne	1b
	
2:
	cp.w	r9, 0
	breq	3f
	sub	r7, r10
	st.w	r9[0], r7

	mov	r12, 0
	
3:
	lda.w	r8, avr32_curlwp
	ld.w	r8, r8[0]
	ld.w	r8, r8[L_ADDR]
	mov	r6, 0
	st.w	r8[U_PCB_ONFAULT], r6

	ldm	sp++,r6-r7, pc
4:
	mov	r12, ENAMETOOLONG
	bral	3b
	.size copyinstr, .-copyinstr

	.text
	.globl copystrerr
	.align 2
copystrerr:
	lddpc	r12, copystrerr_panic	
	rcall	panic

	.align 2
copystrerr_panic: 
	.ascii "copystrerr\0"
	
/*       
 * int suword(void *, int)
 * Stores a word of data to the user-space address.
 */   

	.text
	.globl suword
	.align 1
suword:
	stm	--sp, lr

	/* 
	 * Set fswberr as the error handler
	 */
	lda.w	r8, avr32_curlwp
	ld.w	r8, r8[0]	#curlwp
	ld.w	r8, r8[L_ADDR]
	lda.w	r9, fswberr
	ld.w	r9, r9[0]
	st.w	r8[U_PCB_ONFAULT], r9
		
	st.w	r12[0], r11

	mov	r11, 0
	st.w	r8[U_PCB_ONFAULT], r11
	ldm	sp++, pc
	.size suword,.-suword

fswberr:
	lddpc	r12,fswberr_panic	
	rcall panic

fswberr_panic:
	.ascii "fswberr_panic\0"		
